# Observability Systems - Complete Picture

Build comprehensive understanding of observability systems, architecture, and UX patterns.

## 1. Observability Fundamentals

#### what is observability?

Observability is the capablity of system to allow enginers to understand its internal state based on the data its produced

![observablity](resource/screenshots/image.png)

The pillars of observability is Metrics, Logs, Traces

### Metrics

Metrics are numerical measurements recorded over a time that help us to understand how a system performing

#### Metrics Data contains:

- name : name of the process `process_count`
- value: number of times its counted like `20` request happen
- timestamp: at what time its computed
- labels: its represents in key value pair line `method="GET"`

`api_requests_total{status="200", method="GET"} TIMESTAMP VALUE`

They are best when we want to measure and react fast

- Observing the system performance that can be CPU,Memory usage,
- For setting the alerts (when its exceed the threshold limit)

It helps us to answer the following questions

- Do we need to scale up when its meet the threshold
- Is CPU is working high on the server
- Is the number of failed request increased
- Is API getting slower

#### Types of Metric Format

1. **counter**
1. **Guage**
1. **Histogram**
1. **Summary**

**1. Counter** : As name suggest its used for counting. It only increase and never go down and resets when the system resets (Odometer in bike)

- **Eg:** how many time api request is recived, how many are requested are failed

**2. Guage:** Its like a speedometer in bike that fluctuate. Its value go's up and down

- **Eg:** CPU consumpstion, memory usage by a process

**3. Histogram:** Its like a bar Table in real world analogy where each bar(range like 10-20,20-30) width is repsented as a bucket and the bar height represent the number of occurances happend in that range and it also contains total count and accumulated sum

- **Eg:**: success request in 100ms , 200ms, 100-200ms, as while as failure requests

**Summary:** Its similar to histogram without a bucket, Instead of showing counts for each range, it directly tells you how long it took for a certain percentage of requests to complete.

- **Eg:** p95 means - 95% of requests completed within Y milliseconds.

---

### Logs

Log are texts records generated by the applictioin that describe what happend at a specific moment

#### Log Data contains:

- TimeStamp: When the event happens
- Log Level: What is the type of error like DEBUG, WARN, INFO, ERROR
- Message: Description of what happend like "user login successful"
- Metadata : Its optional, it contains the userID, proceesID, IP address

#### When to use logs?

- When end user facing an issue in appliction
- when we want to know what happend before system crash
- when we want to trace the user actions
- When system throw an error

**_log_** example:
`INFO 2025-10-10T10:21:00Z User login successful {"userId": 57, "ip": "192.168.1.2"}`

#### Types of Log Format

1. **Unstructured Logs**
2. **Structured Logs**

**1. Unstructured Logs** : they are written in plain text which is human readble but hard for machines to figure out.

- **Eg:** `WARN 2025-10-10T10:21:00Z User login suspect {"userId": 57, "ip": "192.168.1.2"}`

**2. Structured Logs** : they are written in JSON format mostly which is human readble and machines also easily understand.

```
{
  "timestamp": "2025-11-19T10:21:00Z",
  "level": "INFO",
  "message": "User login successful",
  "userId": 57,
  "ip": "192.168.1.2",
  "service": "auth-service"
}
```

### Traces

Traces shows the journey of the single request that flows through diffrent services in the system

![Traces Rough Dig](resource/screenshots/traces.png)

#### Trace Data contains:

1. **Operation name**: Name of the operation like payment.verify
1. **start and end timestamp:**: start and end timestamp of the operation
1. **Duration:**: Duration for setteling the operation
1. **Span ID and Trace ID:**: span ID is unique for each step while Trace Id is same for all the steps
1. **Attributes:** it contains the DB query, userID, ..etc

#### When to use Trace?

- When our request is passing threw multiple services
- when we want to trace how much lateny a service is taking
- when we want to debug and find where the issue is happening

#### Concepts in Tracing

1. Spans
1. Trace Context
1. Baggage

**1. Spans:**
A span is a single step in a request Journey. each service creates a new span

**2. Trace Context:**
its a metadata that is needed to continue a trace across services. it has traceID, spanID, sampled

**3. Baggage:** It holds custom data that travels a across services during a trace

### Common protocols:

OTLP, Prometheus exposition format, StatsD, Syslog, Jaeger Thrift

1. **OTLP(OpenTelemetry Protocol)**: Its a modren protocal for sending the metrics, logs, traces. its Highly effcient and its standard

1. **Prometheus Exposition Format**: Its a text based format used for exporting metrics.

1. **Syslog**: Its used for transmitting logs

### Cardinality:

its the number of unique combinations of metric labels like (userId,orderID)

`api_requests_total{status="200", method="GET"}
`
this has 2 labels , 1 time series therfore low cardinality but if we add some more labels and there are millions users then then million timeseries then its high cardinality

Using ID(userid,orderId), timestamps,urls with params, ip address cause the Cardinality Explosion

High cardinality increases the memory usage, CPU usage, System crashes in Prometheus

### Time-Series Nature of Observability Data

Time-series everywhere in onservablity. Data is recorded as pairs (timestamp, value)

its helps to find out the spikes, patterns, latency, changes

**metrics:** `http_requests_total{status="200"} (count timestamp )`

**Logs:** each logs has a timesstamp
`logLevel TimeStamp message`

**Traces:** each span has a start and end timesstamp
`Span: payment.verify
Start: 10:22:00
End:   10:22:180`
